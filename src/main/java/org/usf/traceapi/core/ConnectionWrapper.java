package org.usf.traceapi.core;

import static java.util.Objects.nonNull;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Savepoint;
import java.sql.Statement;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.experimental.Delegate;

/**
 * 
 * @author u$f
 *
 */
@Getter(AccessLevel.PACKAGE)
@Setter(AccessLevel.PACKAGE)
@RequiredArgsConstructor
public final class ConnectionWrapper implements Connection {
	
	@Delegate
	private final Connection cn;
	private final JDBCActionTracer tracer;
	private Runnable onClose;

	@Override
	public Statement createStatement() throws SQLException {
		return tracer.statement(cn::createStatement);
	}
	
	@Override
	public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
		return tracer.statement(()-> cn.createStatement(resultSetType, resultSetConcurrency));
	}
	
	@Override
	public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
		return tracer.statement(()-> cn.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability));
	}
	
	@Override
	public PreparedStatement prepareStatement(String sql) throws SQLException {
		return tracer.preparedStatement(sql, ()-> cn.prepareStatement(sql));
	}
	
	@Override
	public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
		return tracer.preparedStatement(sql, ()-> cn.prepareStatement(sql, resultSetType, resultSetConcurrency));
	}
	
	@Override
	public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
		return tracer.preparedStatement(sql, ()-> cn.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability));
	}
	
	@Override
	public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
		return tracer.preparedStatement(sql, ()-> cn.prepareStatement(sql, autoGeneratedKeys));
	}
	
	@Override
	public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
		return tracer.preparedStatement(sql, ()-> cn.prepareStatement(sql, columnIndexes));
	}
	
	@Override
	public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
		return tracer.preparedStatement(sql, ()-> cn.prepareStatement(sql, columnNames));
	}
	
	@Override
	public Savepoint setSavepoint() throws SQLException {
		return tracer.savePoint(cn::setSavepoint);
	}
	
	@Override
	public Savepoint setSavepoint(String name) throws SQLException {
		return tracer.savePoint(()-> cn.setSavepoint(name));
	}
	
	@Override
	public void commit() throws SQLException {
		tracer.commit(cn::commit);
	}
	
	@Override
	public void rollback() throws SQLException {
		tracer.rollback(cn::rollback);
	}
	
	@Override
	public void rollback(Savepoint savepoint) throws SQLException {
		tracer.rollback(()-> cn.rollback(savepoint));
	}
	
	@Override
	public DatabaseMetaData getMetaData() throws SQLException {
		return tracer.connectionMetadata(cn::getMetaData);
	}
	
	@Override
	public void close() throws SQLException {
		try {
			cn.close();
		}
		finally {
			if(nonNull(onClose)) {
				try {
					onClose.run();
				}
				catch (Exception e) {
					//do nothing
				}
			}
		}
	}
}
